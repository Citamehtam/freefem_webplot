<html>

<head>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/app.css">

    <script src="js/jquery.min.js"></script>
    <script src="js/popper.min.js"></script>
    <!-- <script src="js/Chart.bundle.min.js"></script> -->
    <script src="js/bootstrap.min.js"></script>
    <script src="js/svg.min.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>  
    <script src="js/CSS3DRenderer.js"></script>
    <!-- <script async src="mathjax/MathJax.js"></script> -->



    <!-- Latest compiled and minified JavaScript -->
    <title>FreeFem++</title>
</head>

<body>
    <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
        <a class="navbar-brand" href="#">FreeFem++</a>
    </nav>
    <main role="main" class="container">
        <div class="row">
            <div class="col-8">
                <div id="dashboard_new" class="dashboard jumbotron">
                    <div class="row plot_title">
                        <div class="d-flex flex-fill align-items-center"><h6>Output</h6></div>
                        <div class="d-flex justify-content-end align-items-center">
                            <button type="button" class="btn btn-primary" id="3dstart">2D/3D</button>
                        </div>
                    </div>
                    <div id="new_plot" style="text-align: center" ></div>
                </div>
            </div>
            <div class="col-4">

                <!-- <div id="scheme" class="btn-group scheme" role="group" aria-label="...">
                <button type="button" class="btn btn-default" id="m0">Default</button>
                <button type="button" class="btn btn-default" id="m1">M1</button>
                <button type="button" class="btn btn-default" id="m2">M2</button>
                <button type="button" class="btn btn-default" id="m3">M3</button>
            </div> -->

                <div class="dropdown">

                </div>

                <form id="control" class="controlbox">
                    <h6>Preference</h6>
                    <div class="form-group form-check">
                        <input type="checkbox" class="form-check-input" id="mesh" checked>
                        <label class="form-check-label" for="mesh">mesh</label>
                    </div>
                    <div class="form-group form-check subcheck">
                        <input type="checkbox" class="form-check-input" id="tri_index">
                        <label class="form-check-label" for="tri_index">index of triangles</label>
                    </div>
                    <div class="form-group form-check subcheck">
                        <input type="checkbox" class="form-check-input" id="ver_index">
                        <label class="form-check-label" for="ver_index">index of vertices</label>
                    </div>
                    <div class="form-group form-check">
                        <input type="checkbox" class="form-check-input" id="edg_label">
                        <label class="form-check-label" for="edg_label">label of edges</label>
                    </div>
                    <div class="form-group form-check">
                        <input type="checkbox" class="form-check-input" id="level" checked>
                        <label class="form-check-label" for="level">isoline</label>
                    </div>
                </form>

                <form>
                    <h6>Download</h6>
                    <div class="btn-group" role="group" aria-label="Basic example">
                       <button type="button" class="btn btn-outline-primary" id="dsvg">SVG</button>
                       <button type="button" class="btn btn-outline-primary" id="dpng">PNG</button>
                    </div>
                </form>

            </div>
        </div>
        <canvas id="temp_canvas"></canvas>
    </main>

</body>
<script>
var mesh_data;
var vertex_data;
var edge_data;
var minmax_data;

var draw = SVG('new_plot')

var camera, scene, renderer;
var controls
// var scene2, renderer2;

function init() {

    var frustumSize = 550;
    var aspect = 1;
    camera = new THREE.OrthographicCamera(frustumSize/-2, frustumSize/2, frustumSize/2, frustumSize/-2, 1, 1000);
    camera.position.set(0, 0, 200);
    controls = new THREE.OrbitControls(camera);
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    mygenerate();
    //
    var theatre = document.getElementById("new_plot")

    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(1);
    renderer.setSize(500, 500);

    // renderer = new THREE.CSS3DRenderer();
    // renderer.setSize(510, 510);
    // renderer.domElement.id = 'my3d';
    // renderer.domElement.style.position = 'relative';


    theatre.appendChild(renderer.domElement);

    $(theatre).children('svg').hide();

    
    function mygenerate() {
        const xc = 500;
        const yc = 500;
        const zc = 5000;

        mesh_data.forEach((e)=>{
            var geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3((e[0].x-0.5)*xc, (e[0].y-0.5)*yc, e[0].u*zc));
            geometry.vertices.push(new THREE.Vector3((e[1].x-0.5)*xc, (e[1].y-0.5)*yc, e[1].u*zc));
            geometry.vertices.push(new THREE.Vector3((e[2].x-0.5)*xc, (e[2].y-0.5)*yc, e[2].u*zc));
            geometry.vertices.push(new THREE.Vector3((e[0].x-0.5)*xc, (e[0].y-0.5)*yc, e[0].u*zc));
            mcolor = new THREE.Color('black');
            var material = new THREE.MeshBasicMaterial({ color: mcolor, wireframe: true, wireframeLinewidth: 2, side: THREE.DoubleSide });
            var line = new THREE.Line(geometry, material);
            scene.add(line);
        })
        // mesh_data.forEach((e) => {
        //     indicesOfFaces.push(e[0].index + vertex_data.length, e[1].index+vertex_data.length, e[2].index+ vertex_data.length);
        // })
        // console.log(verticesOfObject, indicesOfFaces)

        // var geometry = new THREE.PolyhedronGeometry(verticesOfObject, indicesOfFaces, 600, 0);
        // var mesh = new THREE.Mesh(geometry, material);
        // scene.add(mesh);
        
    }

}

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

$(document).ready(function () {    

    function mesh_ajax() {
        return $.ajax({
            url: './mesh',
            type: 'GET'
        }).done((m) => {
            console.log(m);
            mesh_data = m;
        }).fail((xhr, status, error) => {
            console.log("Status: " + status + " Error: " + error);
            console.log(xhr);
        })
    }
    
    function vertex_ajax() {
        return $.ajax({
            url: './vertex',
            type: 'GET'
        }).done((m) => {
            console.log(m);
            vertex_data = m;
            minv = m[0].u;
            maxv = m[0].u;
            var mini = 0, maxi = 0;
            m.forEach((e, index) => {
                if (e.u > maxv) {
                    maxv = e.u;
                    maxi = index;
                }
                if (e.u < minv) {
                    minv = e.u;
                    mini = index;
                }
            });
            minmax_data = [{ 'id': mini, 'u': minv }, { 'id': maxi, 'u': maxv }]
        }).fail((xhr, status, error) => {
            console.log("Status: " + status + " Error: " + error);
            console.log(xhr);
        })
    }
    
    function edge_ajax() {
        return $.ajax({
            url: './edge',
            type: 'GET'
        }).done((m) => {
            console.log(m);
            edge_data = m;
        }).fail((xhr, status, error) => {
            console.log("Status: " + status + " Error: " + error);
            console.log(xhr);
        })
    }
    

    $.when(mesh_ajax(), vertex_ajax(), edge_ajax()).done(function () {
        mydraw()
    })

    $('input[type="checkbox"]').change(function () {
        mydraw();
    });

    $('#dsvg').click(function(){
        text = $('#new_plot > svg')[0].outerHTML;
        var file = new Blob([text], { type: 'image/svg+xml' });
        var w = window.open(URL.createObjectURL(file),'test.svg');
    });
    
    $('#dpng').click(function () {
        text = $('#new_plot > svg')[0].outerHTML;
        var file = new Blob([text], { type: 'image/svg+xml' });
        var canvas = document.getElementById('temp_canvas');
        $(canvas).attr('width','1024').attr('height','1024');
        var ctx = canvas.getContext('2d');
        var img = new Image();
        img.src = URL.createObjectURL(file);
        img.onload = function () {
            ctx.drawImage(img, 0, 0,1024,1024);
            var imgURI = canvas
                .toDataURL('image/png')
            var w = window.open(imgURI, 'test.png');
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            $(canvas).attr('width', '0').attr('height', '0');

        };

    })

    $('#3dstart').click(function(){
        if($("#new_plot").children("svg").is(":hidden")){
            $("#new_plot").children("svg").show();
            $("#new_plot").children("canvas").remove();
            controls.enabled = false
            // $("#my3d").remove();
        }else{
            // controls.enabled = true
            init();
            animate();
        }

    });

    
    
});

function mydraw() {
    const sc = 500;
    const w = 1 * sc;
    const h = -1 * sc;
    draw.clear()
    $("#new_plot > svg").attr('height','');
    draw.viewbox({ x: -0.05 * sc, y: -0.05 * sc, width: 1.1 * sc, height: 1.1 * sc })
    var color = new SVG.Color('#0000ff').morph('#ff0000')
    
    if ($("#mesh").is(':checked')){
        mesh_data.forEach((e, i) => {
            var polyline = draw.polygon([[e[0].x * w, e[0].y * h - h ], [e[1].x * w, e[1].y * h - h], [e[2].x * w, e[2].y * h - h]])
            polyline.fill('none').stroke({ width: 1 / 500 * sc })
            if ($("#tri_index").is(':checked')) {
                var text = draw.plain(i).attr('x', (e[0].x + e[1].x + e[2].x) / 3 * w).attr('y', (e[0].y + e[1].y + e[2].y) / 3 * h - h)
                    .font({
                        size: 0.02 * sc + "px",
                        anchor: 'middle'
                    })
            }
        });

        if ($("#ver_index").is(':checked') && typeof vertex_data !== 'undefined') {
            vertex_data.forEach((e, i) => {
                var circle = draw.circle(1 / 100 * sc).attr('cx', e.x*w).attr('cy', e.y * h -h);
                var text = draw.plain(i).attr('x', (e.x - 0.015)*w).attr('y', (e.y + 0.01 - 1) * h )
                    .font({
                        size: 0.02 * sc + "px",
                        anchor: 'middle',
                        fill: '#0000FF'
                    })
            })

        }
    }else{
        edge_data.forEach((e, i) => {
            var line = draw.line(e.vertices[0].x * w, e.vertices[0].y * h - h, e.vertices[1].x * w, e.vertices[1].y * h -h)
                .stroke({ width: 1 / 500 * sc });
        })
    }
    



    if ($("#edg_label").is(':checked') && typeof edge_data !== 'undefined') {
        edge_data.forEach((e, i) => {
            var line = draw.line(e.vertices[0].x*w, e.vertices[0].y*h-h, e.vertices[1].x*w, e.vertices[1].y*h-h)
                        .stroke({ width: 1/500 *sc}).stroke({color: '#f06'});
            var text = draw.plain(e.label).attr('x', (e.vertices[0].x+ e.vertices[1].x)/2 * w - 0.015*sc).attr('y', (e.vertices[0].y+ e.vertices[1].y)/2 * h -h )
                .font({
                    size: 0.02*sc+"px",
                    anchor: 'middle',
                    fill: '#f06'
                })
        })

    }

    if ($("#level").is(':checked') && typeof mesh_data !== 'undefined') {
        nlevel = 20;
        vlevel = [];
        dl = (minmax_data[1].u - minmax_data[0].u)/nlevel;
        vlevel.push(minmax_data[0].u + 0.4 * dl);
        for (let i = 1; i <= nlevel; i++) {
            vlevel.push(minmax_data[0].u+i*dl);
        }
        mesh_data.forEach((e, i) => {
            // vi = 19;
            // ve = vlevel[vi]
            // console.log(ve);
            vlevel.forEach((ve,vi) => {
                level_line = [];
                if ((ve >= e[0].u && ve <= e[1].u) || (ve <= e[0].u && ve >= e[1].u)) {
                    //at 1st edge of the element
                    rate = (ve - e[0].u)/(e[1].u - e[0].u)
                    level_line.push([(rate * e[1].x + ( 1 - rate ) * e[0].x) * w, (rate * e[1].y + (1 - rate) * e[0].y) * h - h])                    
                }
                if ((ve >= e[1].u && ve <= e[2].u) || (ve <= e[1].u && ve >= e[2].u)) {
                    //at 2nd edge of the element
                    rate = (ve - e[1].u) / (e[2].u - e[1].u)
                    level_line.push([(rate * e[2].x + (1 - rate) * e[1].x) * w, (rate * e[2].y + (1 - rate)* e[1].y) * h - h])
                }
                if ((ve >= e[2].u && ve <= e[0].u) || (ve <= e[2].u && ve >= e[0].u)) {
                    //at 3rd edge of the element
                    rate = (ve - e[2].u) / (e[0].u - e[2].u)
                    level_line.push([(rate * e[0].x + (1 - rate) * e[2].x) * w, (rate * e[0].y + (1 - rate) * e[2].y) * h - h])
                }
                var polyline = draw.polyline(level_line).fill('none').stroke({ width: 1 / 500 * sc }).stroke({ color: color.at(vi/nlevel).toHex()  });
            });
        })
    }


    
}



</script>

</html>