<html>

<head>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/app.css">

    <script src="js/jquery.min.js"></script>
    <script src="js/popper.min.js"></script>
    <!-- <script src="js/Chart.bundle.min.js"></script> -->
    <script src="js/bootstrap.min.js"></script>
    <script src="js/svg.min.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>  
    <!-- <script src="js/CSS3DRenderer.js"></script> -->
    <!-- <script async src="mathjax/MathJax.js"></script> -->



    <!-- Latest compiled and minified JavaScript -->
    <title>FreeFem++</title>
</head>

<body>
    <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
        <a class="navbar-brand" href="#">FreeFem++</a>
    </nav>
    <main role="main" class="container">
        <div class="row">
            <div class="col-8">
                <div id="dashboard_new" class="dashboard jumbotron">
                    <div class="row plot_title">
                        <div class="d-flex flex-fill align-items-center"><h6>Output</h6></div>
                        <div class="d-flex justify-content-end align-items-center">
                            <button type="button" class="btn btn-outline-secondary" id="3dstart">2D</button>
                        </div>
                    </div>
                    <div id="new_plot" style="text-align: center" ></div>
                </div>
            </div>
            <div class="col-4">
                <div class="dropdown">

                </div>

                <form id="control" class="controlbox">
                    <h6>Preference (for 2D)</h6>
                    <div class="form-group form-check">
                        <input type="checkbox" class="form-check-input" id="mesh" checked>
                        <label class="form-check-label" for="mesh">mesh</label>
                    </div>
                    <div class="form-group form-check subcheck">
                        <input type="checkbox" class="form-check-input" id="tri_index">
                        <label class="form-check-label" for="tri_index">index of triangles</label>
                    </div>
                    <div class="form-group form-check subcheck">
                        <input type="checkbox" class="form-check-input" id="ver_index">
                        <label class="form-check-label" for="ver_index">index of vertices</label>
                    </div>
                    <div class="form-group form-check">
                        <input type="checkbox" class="form-check-input" id="edg_label">
                        <label class="form-check-label" for="edg_label">label of edges</label>
                    </div>
                    <div class="form-group form-check">
                        <input type="checkbox" class="form-check-input" id="level" checked>
                        <label class="form-check-label" for="level">isoline</label>
                    </div>
                </form>

                <form>
                    <h6>Download</h6>
                    <div class="btn-group" role="group" aria-label="Basic example" id="download_btn">
                       <button type="button" class="btn btn-outline-primary" id="dsvg">SVG</button>
                       <button type="button" class="btn btn-outline-primary" id="dpng">PNG</button>
                    </div>
                </form>

            </div>
        </div>
        <canvas id="temp_canvas"></canvas>
    </main>

</body>
<script>
var mesh_data;
var vertex_data;
var edge_data;
var minmax_data;
//initial for 2D
var draw = SVG('new_plot')

//initial for 3D
var camera, scene, renderer;
var controls

function init() {
    const sc = 1000;
    var frustumSize = sc+sc/10;
    var aspect = 1;
    camera = new THREE.OrthographicCamera(frustumSize/-2, frustumSize/2, frustumSize/2, frustumSize/-2, 1, 2*sc);
    camera.position.set(0, 0, frustumSize);
    controls = new THREE.OrbitControls(camera);
    scene = new THREE.Scene();
    // scene.background = new THREE.Color(0xf0f0f0);
    mygenerate();
    //
    var theatre = document.getElementById("new_plot")

    renderer = new THREE.WebGLRenderer({ alpha: true , preserveDrawingBuffer: true });
    renderer.setPixelRatio(1);
    renderer.setSize(sc, sc);
    renderer.setClearAlpha(0);

    // renderer = new THREE.CSS3DRenderer();
    // renderer.setSize(510, 510);
    // renderer.domElement.id = 'my3d';
    // renderer.domElement.style.position = 'relative';


    theatre.appendChild(renderer.domElement);

    $(theatre).children('svg').hide();

    
    function mygenerate() {
        const xc = sc;
        const yc = sc;
        const zc = sc*10;

        mesh_data.forEach((e)=>{
            var geometry = new THREE.Geometry();
            var v0 = new THREE.Vector3((e[0].x-0.5)*xc, (e[0].y-0.5)*yc, e[0].u*zc);
            var v1 = new THREE.Vector3((e[1].x-0.5)*xc, (e[1].y-0.5)*yc, e[1].u*zc);
            var v2 = new THREE.Vector3((e[2].x-0.5)*xc, (e[2].y-0.5)*yc, e[2].u*zc);
            
            var triangle = new THREE.Triangle(v0, v1, v2);
            var normal = triangle.normal();
            mcolor = new THREE.Color(0x2194ce);
            // var material = new THREE.MeshLambertMaterial({wireframe: true, wireframeLinewidth: 1, side: THREE.DoubleSide });
            var material = new THREE.ShaderMaterial({
                uniforms: {
                    color1: {
                        value: new THREE.Color("#0000ff")
                    },
                    color2: {
                        value: new THREE.Color("#ff0000")
                    },
                    bboxMin: {
                        value: {'x': vertex_data[minmax_data[0].id].x*xc,
                                'y': vertex_data[minmax_data[0].id].y*yc,
                                'z': minmax_data[0].u*zc
                                }
                    },
                    bboxMax: {
                        value: {
                            'x': vertex_data[minmax_data[1].id].x*xc,
                            'y': vertex_data[minmax_data[1].id].x*yc,
                            'z': minmax_data[1].u * zc
                        }
                    }
                },
                vertexShader: `
                                uniform vec3 bboxMin;
                                uniform vec3 bboxMax;
                            
                                varying vec2 vUv;

                                void main() {
                                    vUv.y = (position.z - bboxMin.z) / (bboxMax.z - bboxMin.z);
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                                }
                            `,
                fragmentShader: `
                                uniform vec3 color1;
                                uniform vec3 color2;
                            
                                varying vec2 vUv;
                                
                                void main() {
                                    gl_FragColor = vec4(mix(color1, color2, vUv.y), 1.0);
                                }
                            `,
                wireframe: true,
                wireframeLinewidth: 1 / 500 * sc
            });
            geometry.vertices.push(triangle.a);
            geometry.vertices.push(triangle.b);
            geometry.vertices.push(triangle.c);
            geometry.faces.push(new THREE.Face3(0, 1, 2, normal));
            
            var tri = new THREE.Mesh(geometry, material);
            scene.add(tri);
        })
        
    }

}

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

$(document).ready(function () {    

    function mesh_ajax() {
        return $.ajax({
            url: './mesh',
            type: 'GET'
        }).done((m) => {
            console.log(m);
            mesh_data = m;
        }).fail((xhr, status, error) => {
            console.log("Status: " + status + " Error: " + error);
            console.log(xhr);
        })
    }
    
    function vertex_ajax() {
        return $.ajax({
            url: './vertex',
            type: 'GET'
        }).done((m) => {
            console.log(m);
            vertex_data = m;
            minv = m[0].u;
            maxv = m[0].u;
            var mini = 0, maxi = 0;
            m.forEach((e, index) => {
                if (e.u > maxv) {
                    maxv = e.u;
                    maxi = index;
                }
                if (e.u < minv) {
                    minv = e.u;
                    mini = index;
                }
            });
            minmax_data = [{ 'id': mini, 'u': minv }, { 'id': maxi, 'u': maxv }]
        }).fail((xhr, status, error) => {
            console.log("Status: " + status + " Error: " + error);
            console.log(xhr);
        })
    }
    
    function edge_ajax() {
        return $.ajax({
            url: './edge',
            type: 'GET'
        }).done((m) => {
            console.log(m);
            edge_data = m;
        }).fail((xhr, status, error) => {
            console.log("Status: " + status + " Error: " + error);
            console.log(xhr);
        })
    }
    

    $.when(mesh_ajax(), vertex_ajax(), edge_ajax()).done(function () {
        mydraw()
    })

    $('input[type="checkbox"]').change(function () {
        mydraw();
    });

    $('#dsvg').click(function(){
        text = $('#new_plot > svg')[0].outerHTML;
        var file = new Blob([text], { type: 'image/svg+xml' });
        var w = window.open(URL.createObjectURL(file),'test.svg');
    });
    
    $('#dpng').click(function () {
        text = $('#new_plot > svg')[0].outerHTML;
        var file = new Blob([text], { type: 'image/svg+xml' });
        var canvas = document.getElementById('temp_canvas');
        $(canvas).attr('width','1024').attr('height','1024');
        var ctx = canvas.getContext('2d');
        var img = new Image();
        img.src = URL.createObjectURL(file);
        img.onload = function () {
            ctx.drawImage(img, 0, 0,1024,1024);
            var imgURI = canvas
                .toDataURL('image/png')
            var w = window.open(imgURI, 'test.png');
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            $(canvas).attr('width', '0').attr('height', '0');

        };

    })

    $('#3dstart').click(function(){
        if($("#new_plot").children("svg").is(":hidden")){
            //2D mode
            $(this).text('2D');
            $("#new_plot").children("svg").show();
            $("#new_plot").children("canvas").remove();
            $('#3dpng').remove();
            // disenable camera orbit control
            controls.enabled = false
        }else{
            // controls.enabled = true
            init();
            animate();
            $(this).text('3D');
            $('#download_btn').append('<button type="button" class="btn btn-outline-primary" id="3dpng">3D PNG</button>');
            $('#3dpng').click(function () {
                var canvas = document.querySelector("#new_plot > canvas");
                canvas.getContext("experimental-webgl", { preserveDrawingBuffer: true });
                var imgURI = canvas.toDataURL('image/png');
                var w = window.open(imgURI, 'test.png');
            })
        }

    });

    
    
});

// 2D Draw
function mydraw() {
    const sc = 500;
    const w = 1 * sc;
    const h = -1 * sc;
    draw.clear()
    $("#new_plot > svg").attr('height','');
    draw.viewbox({ x: -0.05 * sc, y: -0.05 * sc, width: 1.1 * sc, height: 1.1 * sc })
    var color = new SVG.Color('#0000ff').morph('#ff0000')
    
    if ($("#mesh").is(':checked')){
        mesh_data.forEach((e, i) => {
            var polyline = draw.polygon([[e[0].x * w, e[0].y * h - h ], [e[1].x * w, e[1].y * h - h], [e[2].x * w, e[2].y * h - h]])
            polyline.fill('none').stroke({ width: 1 / 500 * sc })
            if ($("#tri_index").is(':checked')) {
                var text = draw.plain(i).attr('x', (e[0].x + e[1].x + e[2].x) / 3 * w).attr('y', (e[0].y + e[1].y + e[2].y) / 3 * h - h)
                    .font({
                        size: 0.02 * sc + "px",
                        anchor: 'middle'
                    })
            }
        });

        if ($("#ver_index").is(':checked') && typeof vertex_data !== 'undefined') {
            vertex_data.forEach((e, i) => {
                var circle = draw.circle(1 / 100 * sc).attr('cx', e.x*w).attr('cy', e.y * h -h);
                var text = draw.plain(i).attr('x', (e.x - 0.015)*w).attr('y', (e.y + 0.01 - 1) * h )
                    .font({
                        size: 0.02 * sc + "px",
                        anchor: 'middle',
                        fill: '#0000FF'
                    })
            })

        }
    }else{
        edge_data.forEach((e, i) => {
            var line = draw.line(e.vertices[0].x * w, e.vertices[0].y * h - h, e.vertices[1].x * w, e.vertices[1].y * h -h)
                .stroke({ width: 1 / 500 * sc });
        })
    }
    



    if ($("#edg_label").is(':checked') && typeof edge_data !== 'undefined') {
        edge_data.forEach((e, i) => {
            var line = draw.line(e.vertices[0].x*w, e.vertices[0].y*h-h, e.vertices[1].x*w, e.vertices[1].y*h-h)
                        .stroke({ width: 1/500 *sc}).stroke({color: '#f06'});
            var text = draw.plain(e.label).attr('x', (e.vertices[0].x+ e.vertices[1].x)/2 * w - 0.015*sc).attr('y', (e.vertices[0].y+ e.vertices[1].y)/2 * h -h )
                .font({
                    size: 0.02*sc+"px",
                    anchor: 'middle',
                    fill: '#f06'
                })
        })

    }

    if ($("#level").is(':checked') && typeof mesh_data !== 'undefined') {
        nlevel = 20;
        vlevel = [];
        dl = (minmax_data[1].u - minmax_data[0].u)/nlevel;
        vlevel.push(minmax_data[0].u + 0.4 * dl);
        for (let i = 1; i <= nlevel; i++) {
            vlevel.push(minmax_data[0].u+i*dl);
        }
        mesh_data.forEach((e, i) => {
            // vi = 19;
            // ve = vlevel[vi]
            // console.log(ve);
            vlevel.forEach((ve,vi) => {
                level_line = [];
                if ((ve >= e[0].u && ve <= e[1].u) || (ve <= e[0].u && ve >= e[1].u)) {
                    //at 1st edge of the element
                    rate = (ve - e[0].u)/(e[1].u - e[0].u)
                    level_line.push([(rate * e[1].x + ( 1 - rate ) * e[0].x) * w, (rate * e[1].y + (1 - rate) * e[0].y) * h - h])                    
                }
                if ((ve >= e[1].u && ve <= e[2].u) || (ve <= e[1].u && ve >= e[2].u)) {
                    //at 2nd edge of the element
                    rate = (ve - e[1].u) / (e[2].u - e[1].u)
                    level_line.push([(rate * e[2].x + (1 - rate) * e[1].x) * w, (rate * e[2].y + (1 - rate)* e[1].y) * h - h])
                }
                if ((ve >= e[2].u && ve <= e[0].u) || (ve <= e[2].u && ve >= e[0].u)) {
                    //at 3rd edge of the element
                    rate = (ve - e[2].u) / (e[0].u - e[2].u)
                    level_line.push([(rate * e[0].x + (1 - rate) * e[2].x) * w, (rate * e[0].y + (1 - rate) * e[2].y) * h - h])
                }
                var polyline = draw.polyline(level_line).fill('none').stroke({ width: 1 / 500 * sc }).stroke({ color: color.at(vi/nlevel).toHex()  });
            });
        })
    }


    
}



</script>

</html>